import java.util.ArrayList;

public class ExecutarTestes {

    private static final int T1 = 10000;
    private static final int T2 = 100000;
    private static final int T3 = 1000000;

    private static final int C1 = 100000;
    private static final int C2 = 1000000;
    private static final int C3 = 10000000;

    public static void main(String[] args) {

        //  Geração dos dados UMA ÚNICA VEZ
        System.out.println("Passo 3: Gerando conjuntos de dados com SEED fixa...");
        ArrayList<Registro> dadosC1 = GeradorDados.gerarRegistros(C1);
        ArrayList<Registro> dadosC2 = GeradorDados.gerarRegistros(C2);
        ArrayList<Registro> dadosC3 = GeradorDados.gerarRegistros(C3);
        System.out.println("Geração concluída. Iniciando testes de inserção (Passo 4).");

        int[] tamanhosTabela = {T1, T2, T3};
        ArrayList<Registro>[] conjuntosDados = new ArrayList[]{dadosC1, dadosC2, dadosC3};
        String[] nomesConjuntos = {"100.000", "1 Milhão", "10 Milhões"};
        String[] nomesFuncoes = {"Divisão (1)", "Multiplicação (2)", "Polinomial (3)"};

        // Loop Principal de Testes de Inserção
        for (int tamT : tamanhosTabela) {
            for (int c = 0; c < conjuntosDados.length; c++) {
                ArrayList<Registro> dados = conjuntosDados[c];
                double fatorCarga = (double) dados.size() / tamT;

                System.out.println("\n⁺˚ * • ̩̩͙✩ • ̩̩͙ * ˚⁺‧͙⁺˚ * • ̩̩͙⋆⁺₊⋆Ƹ̵̡Ӝ̵̨̄Ʒ⋆⁺₊⋆ • ̩̩͙ * ˚⁺‧͙⁺˚ * • ̩̩͙✩ • ̩̩͙ * ˚⁺‧͙");
                System.out.printf("Tabela=%d | Conjunto=%s | Fator Carga (α): %.2f\n",
                        tamT, nomesConjuntos[c], fatorCarga);
                System.out.println("⁺˚ * • ̩̩͙✩ • ̩̩͙ * ˚⁺‧͙⁺˚ * • ̩̩͙⋆⁺₊⋆Ƹ̵̡Ӝ̵̨̄Ʒ⋆⁺₊⋆ • ̩̩͙ * ˚⁺‧͙⁺˚ * • ̩̩͙✩ • ̩̩͙ * ˚⁺‧͙");

                for (int f = 1; f <= 3; f++) {
                    String nomeFuncao = nomesFuncoes[f-1];

                    // 1. TESTE DE ENCADENAMENTO
                    TabelaHashEncadeamento tabE = new TabelaHashEncadeamento(tamT);
                    long tInsE = medirInsercao(tabE, dados, f);

                    // 2. TESTE DE SONDAGEM LINEAR
                    TabelaHashSondagemLinear tabSL = new TabelaHashSondagemLinear(tamT);
                    long tInsSL = medirInsercao(tabSL, dados, f);

                    // 3. TESTE DE SONDAGEM QUADRÁTICA
                    TabelaHashSondagemQuadratica tabSQ = new TabelaHashSondagemQuadratica(tamT);
                    long tInsSQ = medirInsercao(tabSQ, dados, f);

                    System.out.printf("Hash: %s\n", nomeFuncao);
                    System.out.printf("  Encadeamento: Tempo: %dms | Colisões: %d\n", tInsE, tabE.getColisoes());
                    System.out.printf("  S. Linear:    Tempo: %dms | Colisões: %d\n", tInsSL, tabSL.getColisoes());
                    System.out.printf("  S. Quadrática: Tempo: %dms | Colisões: %d\n", tInsSQ, tabSQ.getColisoes());
                }
            }
        }
    }

    // Método para medir a inserção
    private static long medirInsercao(Object tabela, ArrayList<Registro> dados, int tipoFuncaoHash) {
        long startTime = System.nanoTime();

        if (tabela instanceof TabelaHashEncadeamento) {
            TabelaHashEncadeamento tab = (TabelaHashEncadeamento) tabela;
            for (Registro r : dados) tab.inserir(r, tipoFuncaoHash);
        } else if (tabela instanceof TabelaHashSondagemLinear) {
            TabelaHashSondagemLinear tab = (TabelaHashSondagemLinear) tabela;
            for (Registro r : dados) tab.inserir(r, tipoFuncaoHash);
        } else if (tabela instanceof TabelaHashSondagemQuadratica) {
            TabelaHashSondagemQuadratica tab = (TabelaHashSondagemQuadratica) tabela;
            for (Registro r : dados) tab.inserir(r, tipoFuncaoHash);
        }

        long endTime = System.nanoTime();
        return (endTime - startTime) / 1000000;
    }
}
